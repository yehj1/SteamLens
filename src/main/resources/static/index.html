<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>è¯„è®ºæŠ“å–ä¸æ´å¯Ÿæµ‹è¯•å°</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: "Microsoft YaHei", Arial, sans-serif; margin: 2rem; background: #f5f6fa; color: #333; }
        h1 { margin-bottom: 0.5rem; }
        section { background: #fff; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); margin-bottom: 1.5rem; }
        label { display: block; margin-top: 0.75rem; font-weight: 600; }
        input, textarea { width: 100%; padding: 0.5rem; margin-top: 0.25rem; border: 1px solid #ccd1d9; border-radius: 4px; }
        button { margin-top: 1rem; padding: 0.6rem 1.2rem; border: none; border-radius: 4px; background: #4a6cf7; color: #fff; cursor: pointer; }
        button:disabled { background: #9aa5ff; cursor: wait; }
        pre { background: #1e1e1e; color: #c7d4f2; padding: 1rem; border-radius: 6px; overflow-x: auto; }
        .inline { display: flex; gap: 1rem; }
        .inline > div { flex: 1; }
        .output-tabs { display: flex; gap: 0.5rem; margin-top: 1rem; align-items: center; }
        .output-tabs button { flex: none; background: #e1e6ff; color: #222; }
        .output-tabs button.active { background: #4a6cf7; color: #fff; }
        .download-btn { margin-left: auto; background: #1f8a4d; color: #fff; }
        .download-btn:disabled { background: #8fc8a8; cursor: not-allowed; }
        .dual-output { display: none; }
        .dual-output.active { display: block; }
    </style>
</head>
<body>
<h1>è¯„è®ºæŠ“å–ä¸æ´å¯Ÿæµ‹è¯•å°</h1>
<p>é€šè¿‡é¡µé¢å¿«é€Ÿè°ƒç”¨åç«¯æ¥å£è¿›è¡Œè¯„è®ºæŠ“å–ä¸æ´å¯Ÿç”Ÿæˆï¼Œç¡®ä¿åç«¯å·²å¯åŠ¨å¹¶å¯è®¿é—®ã€‚</p>

<section>
    <h2>Steam æ¸¸æˆæ´å¯Ÿç”Ÿæˆ</h2>
    <form id="pipeline-form">
        <label>Steam App ID
            <input name="appId" placeholder="730" required>
        </label>
        <div class="inline">
            <div>
                <label>æŠ“å–è¯­è¨€
                    <input name="lang" placeholder="schinese" value="schinese">
                </label>
            </div>
            <div>
                <label>æŠ“å–æ•°é‡ä¸Šé™
                    <input name="limit" type="number" min="50" max="1000" value="300">
                </label>
            </div>
        </div>
        <div class="inline">
            <div>
                <label>æ—¶é—´èŒƒå›´ï¼ˆå¤©ï¼‰
                    <input name="dayRange" type="number" min="0" value="30">
                </label>
            </div>
            <div>
                <label>æ´å¯Ÿæœ€å¤§è¯„è®ºæ•°
                    <input name="maxRows" type="number" min="50" max="1000" value="300">
                </label>
            </div>
        </div>
        <label>API Keyï¼ˆè‹¥å¯ç”¨äº†é‰´æƒï¼‰
            <input name="apiKey" placeholder="ä»…å½“å¼€å¯ X-API-Key æ—¶å¡«å†™">
        </label>
        <button type="submit">ä¸€é”®æŠ“å–å¹¶ç”ŸæˆæŠ¥å‘Š</button>
    </form>
    <small>
        ğŸ” ä¸çŸ¥é“ AppIDï¼Ÿå¯åœ¨ <a href="https://steamdb.info/" target="_blank" rel="noopener noreferrer">SteamDB</a> æœç´¢æ¸¸æˆï¼Œæˆ–ç›´æ¥è®¿é—®
        <code>https://store.steampowered.com/app/<em>AppID</em></code> ç¡®è®¤ã€‚
    </small>
    <pre id="status-log">å¡«å†™ä¿¡æ¯åç‚¹å‡»æŒ‰é’®å¼€å§‹åˆ†æã€‚</pre>

    <div class="output-tabs">
        <button type="button" data-target="insight-json" class="active">ç»“æ„åŒ– JSON</button>
        <button type="button" data-target="insight-md">Markdown æŠ¥å‘Š</button>
        <button type="button" id="download-md" class="download-btn" disabled>ä¸‹è½½ Markdown</button>
    </div>
    <pre id="insight-output" class="dual-output active">ç­‰å¾…åˆ†æç»“æœ...</pre>
    <pre id="insight-md-output" class="dual-output"></pre>
</section>

<script>
    let lastMarkdown = '';
    let lastJsonPretty = '';

    async function handleSubmit(form, endpoint, output, transform, options = {}) {
        const {
            sendingMessage = 'æ­£åœ¨å‘é€è¯·æ±‚...',
            failMessage = 'è¯·æ±‚å¤±è´¥ï¼š',
            skipDisable = false
        } = options;

        const formData = new FormData(form);
        const data = {};
        for (const [key, value] of formData.entries()) {
            if (value !== null && value !== undefined) {
                data[key] = value;
            }
        }
        if (typeof transform === 'function') {
            transform(data);
        }
        const headers = { 'Content-Type': 'application/json' };
        if (data.apiKey && data.apiKey.trim().length > 0) {
            headers['X-API-Key'] = data.apiKey.trim();
        }
        delete data.apiKey;

        for (const key of Object.keys(data)) {
            if (data[key] === '') {
                delete data[key];
            }
        }

        for (const key of Object.keys(data)) {
            const value = data[key];
            if (typeof value === 'string' && !Number.isNaN(Number(value))) {
                const numeric = Number(value);
                if (!Number.isNaN(numeric) && value.trim() === numeric.toString()) {
                    data[key] = numeric;
                }
            }
        }

        if (output) {
            output.textContent = sendingMessage;
        }
        const button = form.querySelector('button');
        if (!skipDisable && button) {
            button.disabled = true;
        }
        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers,
                body: JSON.stringify(data)
            });
            const text = await response.text();
            if (output) {
                output.textContent = `${response.status} ${response.statusText}\n\n${text}`;
            }
            return { status: response.status, ok: response.ok, body: text };
        } catch (err) {
            if (output) {
                output.textContent = failMessage + err;
            }
            return null;
        } finally {
            if (!skipDisable && button) {
                button.disabled = false;
            }
        }
    }

    const statusLog = document.getElementById('status-log');
    const outputJsonEl = document.getElementById('insight-output');
    const outputMdEl = document.getElementById('insight-md-output');
    const downloadBtnEl = document.getElementById('download-md');
    let currentAppId = '';

    document.getElementById('pipeline-form').addEventListener('submit', async function (event) {
        event.preventDefault();
        const form = event.target;
        const button = form.querySelector('button');
        button.disabled = true;
        downloadBtnEl.disabled = true;
        outputJsonEl.textContent = 'ç­‰å¾…åˆ†æç»“æœ...';
        outputMdEl.textContent = '';
        lastMarkdown = '';
        lastJsonPretty = '';

        const appIdInput = form.querySelector('input[name="appId"]');
        currentAppId = appIdInput ? appIdInput.value.trim() : '';

        statusLog.textContent = 'â‘  æ­£åœ¨æŠ“å– Steam è¯„è®º...';

        const fetchResult = await handleSubmit(form, '/fetch/steam', null, data => {
            data.appId = data.appId?.trim();
            if (!data.lang || data.lang === '') {
                data.lang = 'all';
            }
            if (!data.filter || data.filter === '') {
                data.filter = 'recent';
            }
            data.reviewType = 'all';
            data.purchaseType = 'all';
            delete data.maxRows;
            delete data.countries;
        }, { skipDisable: true, sendingMessage: '', failMessage: 'è¯·æ±‚å¤±è´¥ï¼š' });

        if (!fetchResult || !fetchResult.ok) {
            statusLog.textContent += `\næŠ“å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–å‚æ•°ã€‚`;
            button.disabled = false;
            return;
        }

        let savedText = '';
        try {
            const parsed = JSON.parse(fetchResult.body);
            if (parsed && typeof parsed.saved !== 'undefined') {
                savedText = `ï¼Œæ–°å¢ ${parsed.saved} æ¡è¯„è®º`;
            }
        } catch (_) {
            // ignore parse errors for status
        }
        statusLog.textContent += `
æŠ“å–å®Œæˆ${savedText}ã€‚`;

        statusLog.textContent += `\nâ‘¡ æ­£åœ¨ç”Ÿæˆæ´å¯ŸæŠ¥å‘Š...`;

        const insightResult = await handleSubmit(form, '/insights/summarize', outputJsonEl, data => {
            const id = data.appId;
            data.packageId = id;
            delete data.appId;
            if (data.countries) {
                data.countries = data.countries.split(',').map(s => s.trim()).filter(Boolean);
                if (data.countries.length === 0) {
                    delete data.countries;
                }
            }
            if (!data.lang || data.lang === '') {
                data.lang = 'schinese';
            }
            delete data.limit;
            delete data.dayRange;
            delete data.filter;
            delete data.reviewType;
            delete data.purchaseType;
        }, { skipDisable: true, sendingMessage: 'æ­£åœ¨è¯·æ±‚æ´å¯Ÿ...', failMessage: 'è¯·æ±‚å¤±è´¥ï¼š' });

        if (!insightResult || !insightResult.ok) {
            statusLog.textContent += `\næ´å¯Ÿç”Ÿæˆå¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—ã€‚`;
            button.disabled = false;
            return;
        }

        const bodyStart = outputJsonEl.textContent.indexOf('\n\n');
        const rawBody = bodyStart >= 0 ? outputJsonEl.textContent.slice(bodyStart + 2) : outputJsonEl.textContent;

        try {
            const parsed = JSON.parse(rawBody);
            let summaryJson = parsed.summaryJson;
            if (typeof summaryJson === 'string') {
                try {
                    summaryJson = JSON.parse(summaryJson);
                } catch (_) {
                    // keep string
                }
            }
            if (summaryJson) {
                const pretty = typeof summaryJson === 'object'
                    ? JSON.stringify(summaryJson, null, 2)
                    : summaryJson;
                outputJsonEl.textContent = pretty;
                lastJsonPretty = pretty;
            }

            let markdown = parsed.summaryMd;
            if (!markdown && summaryJson) {
                markdown = generateMarkdown(summaryJson, currentAppId);
            }
            if (markdown) {
                outputMdEl.textContent = markdown;
                lastMarkdown = markdown;
                downloadBtnEl.disabled = false;
                triggerMarkdownDownload(`Steam-${currentAppId || 'report'}-${Date.now()}.md`);
                statusLog.textContent += `\nâ‘¢ æ´å¯Ÿç”Ÿæˆå®Œæˆï¼Œå·²è‡ªåŠ¨ä¸‹è½½ Markdown æŠ¥å‘Šã€‚`;
            } else {
                statusLog.textContent += `\nâ‘¢ æ´å¯Ÿç”Ÿæˆå®Œæˆã€‚`;
            }
        } catch (err) {
            outputJsonEl.textContent += `\n\nè§£æå“åº”å¤±è´¥ï¼š${err}`;
            statusLog.textContent += `\nç»“æœè§£æå¤±è´¥ï¼Œè¯·æŸ¥çœ‹ç»“æ„åŒ– JSONã€‚`;
        }

        button.disabled = false;
    });

    document.querySelectorAll('.output-tabs button').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.output-tabs button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            document.querySelectorAll('.dual-output').forEach(el => el.classList.remove('active'));
            const targetId = btn.getAttribute('data-target');
            document.getElementById(targetId === 'insight-json' ? 'insight-output' : 'insight-md-output').classList.add('active');
        });
    });

    document.getElementById('download-md').addEventListener('click', () => {
        triggerMarkdownDownload();
    });

    function triggerMarkdownDownload(filename) {
        if (!lastMarkdown) {
            return;
        }
        const blob = new Blob([lastMarkdown], { type: 'text/markdown;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename || `æ´å¯ŸæŠ¥å‘Š-${Date.now()}.md`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    function generateMarkdown(summary, appId) {
        let data = summary;
        try {
            if (typeof summary === 'string') {
                data = JSON.parse(summary);
            }
        } catch (_) {
            return summary;
        }
        if (typeof data !== 'object' || data === null) {
            return String(summary);
        }
        const lines = [];
        lines.push(`# æ´å¯ŸæŠ¥å‘Šï¼ˆSteam AppID: ${appId || 'æœªçŸ¥'}ï¼‰`);
        if (Array.isArray(data.themes) && data.themes.length) {
            lines.push('\n## ä¸»é¢˜æ¦‚è§ˆ');
            data.themes.forEach((theme, idx) => {
                lines.push(`\n### ${idx + 1}. ${theme.name ?? 'æœªå‘½åä¸»é¢˜'}`);
                if (theme.count !== undefined) {
                    lines.push(`- æåŠæ¬¡æ•°ï¼š${theme.count}`);
                }
                if (theme.neg_ratio !== undefined) {
                    const percent = typeof theme.neg_ratio === 'number'
                        ? `${Math.round(theme.neg_ratio * 100)}%`
                        : theme.neg_ratio;
                    lines.push(`- è´Ÿå‘å æ¯”ï¼š${percent}`);
                }
                if (Array.isArray(theme.sample_quotes) && theme.sample_quotes.length) {
                    lines.push('- ç¤ºä¾‹å¼•ç”¨ï¼š');
                    theme.sample_quotes.forEach(q => lines.push(`  - ${q}`));
                }
                if (Array.isArray(theme.related_needs) && theme.related_needs.length) {
                    lines.push('- ç›¸å…³éœ€æ±‚ï¼š');
                    theme.related_needs.forEach(n => lines.push(`  - ${n}`));
                }
            });
        }
        if (data.overall && typeof data.overall === 'object') {
            lines.push('\n## æ•´ä½“æƒ…æ„Ÿ');
            Object.entries(data.overall).forEach(([key, value]) => {
                lines.push(`- ${translateSentimentKey(key)}ï¼š${value}`);
            });
        }
        if (Array.isArray(data.key_findings) && data.key_findings.length) {
            lines.push('\n## å…³é”®å‘ç°');
            data.key_findings.forEach((finding, idx) => {
                lines.push(`${idx + 1}. ${finding}`);
            });
        }
        lines.push('\n---\næŠ¥å‘Šç”± GreyMatter Steam æ´å¯Ÿå¼•æ“è‡ªåŠ¨ç”Ÿæˆã€‚');
        return lines.join('\n').trim();
    }

    function translateSentimentKey(key) {
        switch (key) {
            case 'pos':
                return 'æ­£å‘';
            case 'neg':
                return 'è´Ÿå‘';
            case 'neu':
                return 'ä¸­æ€§';
            default:
                return key;
        }
    }
</script>

</body>
</html>
